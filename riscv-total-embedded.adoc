
= riscv-total-embedded
Jan Oleksiewicz <jnk0le@hotmail.com>
:appversion: 0.1.0
:toc:
:toclevels: 4
:sectnums:


{author} {email} +
document version {appversion} +
extension status: unstable/PoC +
This document is released under a Creative Commons Attribution 4.0 International License

[colophon]
== revision history


[colophon]
== preface

This document uses semantic versioning with respect to potential hardware designs. 
Assembly syntax change is a minor increment. Version 1.0.0 is the first publicly released. 
Changes in prior versions are not versioned properly and not tracked in revision history.

Document is written in a way that reduces the duplications as those are hard to maintain.

== Introduction

even though is great for unix interrupts 

instead of adding more and more on top of legacy interrupt architecture

replace volume II (aka riscv privileged)


achieve 0 jitter, single digit cycles of interrupt latency (to actual code)

=== prior art

==== cortex-m NVIC

==== CLIC

==== emb-riscv

clean sheet designs
attempts to be


==== PLIC/AIA


out of scope for microcontrolers

==== CLINT

already a legacy



=== overwiew of some concepts/features

==== whole app doable in C/C++

Interrupts must always push all caller saved registers to be able to use functions without 
`__attribute__((interrupt))` annotation.

NOTE: those are usually wrapped with `extern "C" anyway

It also requires preinitialized table with pointer to startup code, `sp`, and `gp`, and of course
any other addition like Zcmt `JVT` csr. A bit of added complexity.

It is also not necessarily smaller than software setup, e.g. `sp` can be usually
done with single `lui` instruction.

Of course I often find that there is a competition on who will make
the worst startup code in assembly. 
So pure C/C++ startup code turns out to be "better" due to confirmation effect.
But let's have a look at my "combotablecrt" implementation <<combotablecrt>> for stm32f030x4/6. 
Is your compiler able to do that?

==== ABIs with less caller saved registers

==== trying to be too universal

great flexibility comes with great inefficiencies.

==== handler return pattern

NVIC and emb-riscv


=== required ABI

get rid of `tp` register

==== RV32E

==== RV32I


=== tooling issues to solve

==== prestacked annotation 

==== IPRA

in llvm


== programmers model
//?????
//non profile ext

//common
	//optional tiny vect table

//profiles
//tiny
	//limited features
	//??

//medium

[appendix]
== sth


[bibliography]
== Bibliography

* [[[embriscv, 1]]] https://github.com/emb-riscv/specs-markdown
* [[[clic, 2]]] https://github.com/riscv/riscv-fast-interrupt/blob/master/clic.adoc

* [[[combotablecrt, 3]]] https://github.com/jnk0le/simple-crt/blob/master/cm0/combotablecrt_stm32f030x6.S