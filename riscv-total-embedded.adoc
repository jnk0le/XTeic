
= riscv-total-embedded
Jan Oleksiewicz <jnk0le@hotmail.com>
:appversion: 0.1.6
:toc:
:toclevels: 4
:sectnums:


{author} {email} +
document version {appversion} +
extension status: unstable/PoC +
This document is released under a Creative Commons Attribution 4.0 International License

[colophon]
== revision history


[colophon]
== preface

This document uses semantic versioning with respect to potential hardware designs. 
Assembly syntax change is a minor increment. Version 1.0.0 is the first publicly released. 
Changes in prior versions are not versioned properly and not tracked in revision history.

Document is written in a way that reduces the duplications as those are hard to maintain.

== Introduction

even though 

is great for unix interrupts

it fails to meet 

embedded/hard real time requirements


instead of adding more and more on top of legacy interrupt scheme, trying to be 
compatible with everything

let's
replace volume II (aka riscv privileged)

with minimal yet efficient

the goal is to
achieve 0 jitter, single digit cycles of interrupt latency (to actual code)

=== prior art

A quick recap of what we already have.

==== cortex-m NVIC

defacto established "industry standard" of efficient interrupt handling.
Anyone complaining about risc-v likes the NVIC.

==== CLIC

<<clic>> is a designated goto for interrupt handling to fulfill everyone needs.
Development took long enough to achieve pre-freeze implementations by some chinese vendors.

Attempts to be an unix compatible interrupt controller with horizontal nesting of U, S and M mode. (including U mode interrupts)

preemption is handled in software 

preemption 
(even in inline handlers)



handlers divided into inline and trampoline dispathced ones

introduces concept of
C function dispatcher/trampoline
very long latency to actual instruction
late arrival `mnxti`
high jitter




==== emb-riscv

<<embriscv>> is clean sheet designs
that attempts to be too universal

lot of redundancy
U+M
separate tables for exceptions and interrupts

mandatory 64bit cycle counter
mandatory 64bit instret counter
mandatory 64bit system timer
mandatory 64bit rtc timer

NOTE: Y2038 can be solved by less than 32 extra bits, even simple uint32_t trick gives us extra ~68 years.
Many RTC implementations are also BCD or BCD like with e.g. separate uint8_t fields for seconds, minutes, day, year etc.

currently development stalled

==== CLINT

Attaches to generic interrupt scheme.

According to <<clint>>, it provides memory mapped interface for timers and IPI.

NOTE: ofiicial CLINT is callet ACLINT but doesn't differ much from CLINT in sifive documentations.

==== generic riscv interrupts as described in "privileged" volume II 

Very often refered to as CLINT. e.g. <<sififeintcookbook>> indirectly claims that volume II 
stuff is CLINT exclusive.

has vectored mode which simply jumps to the position in vector table.

Doesn't provide any nesting other than privilege levels
Registers and CSR state (`fcsr` etc.) have to be pushed by software before use

==== PLIC/AIA

A heavyweight frontend for delivering interrupts to multiple cores 
running typical unix OS. Not suitable for microcontrolers.

claim/complete architecture

handlers stay very similar to generic case.

==== CH32 FPIC/PFIC






inherits behaviour/patterns of 

==== PicoRV32 interrupts

> Note: The IRQ handling features in PicoRV32 do not follow the RISC-V Privileged ISA specification.
> Instead a small set of very simple custom instructions is used to implement IRQ handling with minimal hardware overhead.

Original author of the PicoRV found the riscv-privileged to be too heavy for minimal core,
and provided own <<picorvint>> interrupt scheme.

=== overwiew/discussion of some concepts/features

==== whole app must be doable in C/C++

In this case interrupts must always push all caller saved registers to be able to use functions without 
`__attribute__((interrupt*))` annotation.

NOTE: those are usually wrapped with `extern "C" anyway

It also requires preinitialized table with pointer to startup code, `sp`, and `gp`, and of course
any other addition like Zcmt `JVT` csr.

This table is also not necessarily smaller than software setup, e.g. `sp` can be usually
done with single `lui` instruction. At the cost of a bit added HW complexity.

There is still a risk of corruption if the compiler decides to reorder something before
initialization of `.data`/`.bss` sections.

Of course I often find that there is a competition on who will make
the worst startup code in assembly. 
So pure C/C++ startup code turns out to be "better" due to confirmation effect.
But let's have a look at my "combotablecrt" implementation <<combotablecrt>> for stm32f030x4/6. 
Is your compiler able to do that?

There is also a case of interrupt handlers that are using only a few registers
and don't need to take latency of the whole ABI.

==== ABIs with less caller saved registers

The rationale of introducing ABIs with reduced number of caller saved registers is to 
reduce interrupt latence. The major downside of such approach is lowered overall performance 
and code denisty.

<<tooling issues to solve,aaa>>
<<IPRA,bbb>>

==== RVE EABI being subset of RVI

to be able to call RVE only code from RVI ABI

common in eabi proposals
static compiled

==== trying to be too universal

high flexibility
redundancy
waste of

==== handler return pattern

NVIC and emb-riscv

==== vector tables containing jump instructions

supposedly

works in classic ARM FIQ, and 8051 assembly

==== memory mapped vs CSR mapped configuration

in case of mass initialization

=== required ABI

ideally not change
avoid disruption

definitely get rid of `tp` register

==== RV32E

==== RV32I

=== stack alignment



=== tooling issues to solve

==== prestacked annotation

//e.g. `tp` cannot be changed to caller saved due to existing hardware pre-stackers (ch32)

==== IPRA

in llvm

<<llvmipra>>

//???===== regression due to


== programmers model
//?????
//non profile ext

//common
	//optional tiny vect table

//profiles
//tiny
	//limited features
	//??

//medium

[appendix]
== appendix


[bibliography]
== Bibliography

* [[[embriscv, 1]]] https://github.com/emb-riscv/specs-markdown
* [[[clic, 2]]] https://github.com/riscv/riscv-fast-interrupt/blob/master/clic.adoc
* [[[clint, 3]]] https://github.com/riscv/riscv-aclint/blob/main/riscv-aclint.adoc
* [[[sififeintcookbook, 4]]] https://starfivetech.com/uploads/sifive-interrupt-cookbook-v1p2.pdf
* [[[plic, 5]]] https://github.com/riscv/riscv-plic-spec
* [[[aia, 6]]] https://github.com/riscv/riscv-aia
* [[[combotablecrt, 7]]] https://github.com/jnk0le/simple-crt/blob/master/cm0/combotablecrt_stm32f030x6.S
* [[[llvmipra, 8]]] https://reviews.llvm.org/D23980
* [[[picorvint, 9]]] https://github.com/YosysHQ/picorv32#custom-instructions-for-irq-handling