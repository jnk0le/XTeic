
= riscv-total-embedded
Jan Oleksiewicz <jnk0le@hotmail.com>
:appversion: 0.1.16
:toc:
:toclevels: 4
:sectnums:


{author} {email} +
document version {appversion} +
extension status: unstable/PoC +
This document is released under a Creative Commons Attribution 4.0 International License

[colophon]
== revision history


[colophon]
== preface

This document uses semantic versioning with respect to potential hardware designs. 
Assembly syntax change is a minor increment. Version 1.0.0 is the first publicly released. 
Changes in prior versions are not versioned properly and not tracked in revision history.

Document is written in a way that reduces the duplications as those are hard to maintain.

== Introduction

Even though the current risc-v interrupt architecture is great for unix systems.
It fails to meet many embedded and hard real time requirements.

Instead of adding more and more on top of layered legacy, let's replace
entire volume II (aka riscv privileged) with minimal yet efficient interrupt architecture.

The goal is to achieve single digit cycles of interrupt latency (to actual code) with minimal jitter
without wasting transistors on useless functionality.

=== prior art

A quick recap of what we already have available.

==== cortex-m NVIC

<<armnvic>> defacto established "industry standard" of efficient interrupt handling.
Anyone complaining about risc-v likes and wants the NVIC.

==== CLIC

<<clic>> is a designated goto for interrupt handling to fulfill everyone needs.
Development took long enough to achieve pre-freeze implementations by some chinese vendors.

Attempts to be an unix compatible interrupt controller with horizontal nesting of U, S and M mode. (including U mode interrupts)

preemption is handled in software 

preemption 
(even in inline handlers)



handlers divided into inline and trampoline dispathced ones

introduces concept of
C function dispatcher/trampoline
very long latency to actual instruction
late arrival `mnxti`
high jitter


NOTE: BTW, my prediction is that the "competitor A" will be able to do a 
"comparison against riscv" without resorting to FUD tactics, right after CLIC is ratified

==== emb-riscv

<<embriscv>> is clean sheet designs
that attempts to be too universal

lot of redundancy
U+M
separate tables for exceptions and interrupts

mandatory 64bit cycle counter
mandatory 64bit instret counter
mandatory 64bit system timer
mandatory 64bit rtc timer

NOTE: Y2038 can be solved by less than 32 extra bits, even simple uint32_t trick gives us extra ~68 years.
Many RTC implementations are also BCD or BCD like with e.g. separate uint8_t fields for seconds, minutes, day, year etc.

currently development stalled

==== CLINT

Attaches to generic interrupt scheme.

According to <<clint>>, it provides memory mapped interface for timers and IPI.

NOTE: ofiicial CLINT is callet ACLINT but doesn't differ much from CLINT in sifive documentations.

==== generic riscv interrupts as described in "privileged" volume II 

Very often refered to as CLINT. e.g. <<sififeintcookbook>> indirectly claims that volume II 
stuff is CLINT exclusive.

has vectored mode which simply jumps to the position in vector table.

Doesn't provide any nesting other than privilege levels
Registers and CSR state (`fcsr` etc.) have to be pushed by software before use

==== PLIC/AIA

<<plic>>, <<aia>>

A heavyweight frontend for delivering interrupts to multiple cores 
running typical unix OS. Not suitable for microcontrolers.

claim/complete architecture

handlers stay very similar to generic case.

==== CH32 FPIC/PFIC



undocumented "EABI" mode (except just the presence of it)


inherits behaviour/patterns of 

==== PicoRV32 interrupts

> Note: The IRQ handling features in PicoRV32 do not follow the RISC-V Privileged ISA specification.
> Instead a small set of very simple custom instructions is used to implement IRQ handling with minimal hardware overhead.

Original author of the PicoRV found the riscv-privileged to be too heavy for minimal core,
and provided own <<picorvint>> interrupt scheme.

=== overwiew/discussion of some concepts/features

==== whole app must be doable in C/C++

In this case interrupts must always push all caller saved registers to be able to use functions without 
`\\__attribute__\((interrupt*))` annotation.

NOTE: those are usually wrapped with `extern "C"` anyway

It also requires preinitialized table with pointer to startup code, `sp`, and `gp`, and of course
any other addition like Zcmt `JVT` csr.

This table is also not necessarily smaller than software setup, e.g. `sp` can be usually
done with single `lui` instruction. At the cost of a bit added HW complexity.

There is still a risk of corruption if the compiler decides to reorder something before
initialization of `.data`/`.bss` sections.

Of course I often find that there is a competition on who will make
the worst startup code in assembly. 
So pure C/C++ startup code turns out to be "better" due to confirmation effect.
But let's have a look at my "combotablecrt" implementation <<combotablecrt>> for stm32f030x4/6. 
Is your compiler able to do that?

There is also a case of interrupt handlers that are using only a few registers
and don't need to take latency of the whole ABI.

==== ABIs with less caller saved registers

The rationale of introducing ABIs with reduced number of caller saved registers is to 
reduce interrupt latency. 

The major downside of such approach is lowered overall performance 
and code denisty. Which is highly unliked across riscv community <<bhvseabi>> and stalls 
development of such (E)ABI.

> I think for marketing reasons we should have the RISC-V EABI mimic the competitor ABI as 
> closely as possible, and be available and supported by the tools, even if almost no-one 
> should end up actually using it.

Zcmp[e] was also prepared for such fragmentation by reserving first 4 points in rlist for EABI,
so the cores can implement UABI and EABI push/pop instructions at the same time.
Those 4 points are of course supposed to handle 20 caller saved regs of EABI (probably with some 
reuse of few higher points).

It will also make the processors capable of stacking 2 registers per cycle, underutiized
during HW stacking due to shorter stacking time than pipeline refill.

An alternative is to provide interrupts with defacto customizable ABIs by e.g. <<prestacked annotation>>
(to match the HW stackers) and handle the function call pressure by <<IPRA>>.

==== "you are better of with soft stacking in inline handlers"

aka generic riscv `\\__attribute__\((interrupt))`

First major issue is decreased code density due to all of the stacking code.

Compilers also barely care about optimizing for register pressure in interrupts.
The prologues/epilogues seem to be completely transparent for code generation.
Which is especially visible in cases where majority of the prologue/epilogue code could 
be easily conditionally skipped, but compilers simply don't do it.
(just the loads/stores, stack can be fully preallocated on entry)

NOTE: avr8-gcc for a very long time was emitting useless prologues/epilogues for pushing `SREG`, `r0`, `r1` and clearing `r1`
even though those were not affected or used by ISR code. Of course the version that finally fixed it, was never 
shipped in Atmel Studio.

NOTE: Zcmp[e] doesn't cover caller saved registers except `ra`.

The other one is one of the principles of hardware stackers.

When entering interrupt handler, the core first fetches the entry from vector table and then
jumps to that address. Both of those fetches can hit a flash waitstate or a cache miss.
During that operation the data bus remains idle waiting for a first store instruction to be executed.

Those cycles can be accomodated for a "free" stacking of registers. If a higher amount of
registers is stacked then it can hide a bit of jitter coming from cache misses or flash waitstates.

Even stacking by the special push instructions (e.g. XTheadInt <<thead>> or
PUSHINT <<pushint>> and maybe a subsets of those), won't help much. Those start pushing
after the latency of double (waitstated) miss was taken.

==== EABI for RVE must be subset of RVI EABI.

To be able to call RVE only code from RVI ABI +
Recurrig thing in RVE ABI proposals.

The idea is to allow compilers and software vendors to provide a single
set of precompiled libraries for RVI and RVE ABIs.

The issue with this approach is that the code arbitrarily compiled for RVE 
might turn out to be less efficient than RVI one. It also limits the capabilities
of RVI ABI like trading off argument registers for temporary/saved ones.

==== one universal standard for everyones use cases

Having one universal solution for all possible configs
brings a lot of inefficiency to all of them. Due to mandatory 
support for a lot of useless functionality, or just the need 
to keep optional compatibility with useless legacy "just in case".

==== special handler return pattern

aka "HANDLER_RETURN" on emb-riscv and "EXC_RETURN" on ARM

The idea is to put special pattern in `ra` during handler entry and
exit by reusing regular return mechanism provided by the ABI. Requires 
certain memory area to be non executable (e.g. 0xF0000000 - 0xFFFFFFFF)

This mechanism follows the typical ABI function call and together with HW 
stacking, allows the interrupt handlers to be a regular C functions.

The downside is that the `ra` and `pc` both have to be pushed onto stack
and in some specifc cases, it could add extra stall cycles after the tail due
to the waitstates/cache miss caused by delayed prefetch.

Alternatively we can just stack the `ra` and put there current `pc` with lowest bit set 
to trigger handler return operation. One less register counted towards interrupt latency.

NOTE: normally the `jalr` instruction just ignores the LSB bit of resulting address.
LSB in register and immediate will lead to "bogus" jump over 2 extra bytes.
Even though this behaviour simplifies hardware, it was oversighted in ABI design 
by allowing "auxiliary information" in pointers as well as `jalr` 
immediate, effectively making both useless.

==== vector tables containing jump instructions

It's simply inefficient in truly vectored scenario.
The vector entries will have to be populated with jump instructions anyway.
Those have to take the second round of waitstates/cache miss without amortization by register stacking.

And if the code is far away from vector table (e.g. in SRAM for more deterministic execution),
compiler will have to emit a jump island, aka "veener", that will perform yet another unamortized jump.
allocating 8 bytes per entry and enforcing `lui` + `jalr` sequence will severly trump the 
code density and performance in typical use scenarios.

NOTE: 8051 allocated 8 bytes per entry, but it was able to sometimes fit entire handler or
one of the conditional path. Especially when following entries were unused. This kind of 
optimizations is exlusive to assmebly programming and not practised today.

==== MMIO vs CSR mapped config registers

In case of mass initialization MMIO could result in better code density
CSR space is also limited.

My take is that anything architecturally coupled to the core should reside 
in CSR space and keep the rest in MMIO.

Nothing should exist as both.

==== "reduced/zero jitter"

Cortex-m0 offers a "zero jitter" by optional IP configuration that adjusts the best case 
of interrupt latency by extra cycle to acommodate random stall from bus contention.

Cortex-m3/4 offer up to 6 cycles of jitter due to "late arrival" and "pop pre-emption".

Cortex-cm7 of course suffers from Proprietary&Confidential syndrome. 
Most probably it's similar to cm3/4.

In case of C2000 CLA, TI claims <<spracs0a>>,<<ticladocs>> that their task driven machine 
(non preemptible) "reduces interrupt latency and jitter" compared to classic CPU, even
though it does exactly the opposite when there is more than 1 async interrupt to handle.

NOTE: Of course whenever TI compares CLA to "classic cpu", it's always a cpu with preemption 
priority only and background task not present on CLA. As if the similar "task machine" couldn't
be achieved by regular cpu (e.g. risc-v) without nesting and WFI loop (or "sleep on exit" feature) 
giving access to all GPRs in interrupts without stacking.

==== "everything will run Linux in future"

The Linux cargo cult. +
Because a simplest tasks suitable for bunch of 555&74s or a simple microcontroler with a 
few KiB of flash and RAM must be done under linux so it will work somehow "better".

To be able to properly run linux you need quite beefy cpu with a proper MMU, 2-4MiB of flash, 
4-8MiB of RAM (usually external DRAM), long boot time and a bad power consumption in idle. +
Just to run the OS itself.

One of the the most blatant example is NOMMU linux on stm32f429 with SDRAM that is not cached by cpu.

Of course there are there are actual reasons <<emblinux>> to use linux in embedded.

===== RTLinux and hard-realtime

Whenever those rt patches are measured, both the interrupt latency and 
jitter is always given in microseconds (10-100), not cycles 
<<linuxrt1>>,<<linuxrt2>>,<<linuxrt3>>,<<linuxrt4>>.

In some scenarios those numbers are unacceptable.

=== required ABI

ideally not change
avoid disruption

but may need

definitely get rid of `tp` register, it's useless here.

==== RV32E

==== RV32I

==== stack alignment



=== tooling issues to solve

==== prestacked annotation

//e.g. `tp` cannot be changed to caller saved due to existing hardware pre-stackers (ch32)

==== IPRA

in llvm <<llvmipra>>

in simple explanation



very little information foundable can be googled
mostly llvm 

even if there is something benchmarked
of course -O3 (forget about -Os and -Oz)



//???===== regression due to

==== automatic selection of regpush on isr entry config

== programmers model
//?????
//non profile ext
//little endian only

//common
	//optional tiny vect table

//profiles
//tiny
	//limited features
	//??

//medium

[appendix]
== context switch on tiny profile


[bibliography]
== Bibliography

* [[[embriscv, 1]]] https://github.com/emb-riscv/specs-markdown
* [[[clic, 2]]] https://github.com/riscv/riscv-fast-interrupt/blob/master/clic.adoc
* [[[clint, 3]]] https://github.com/riscv/riscv-aclint/blob/main/riscv-aclint.adoc
* [[[sififeintcookbook, 4]]] https://starfivetech.com/uploads/sifive-interrupt-cookbook-v1p2.pdf
* [[[plic, 5]]] https://github.com/riscv/riscv-plic-spec
* [[[aia, 6]]] https://github.com/riscv/riscv-aia
* [[[combotablecrt, 7]]] https://github.com/jnk0le/simple-crt/blob/master/cm0/combotablecrt_stm32f030x6.S
* [[[llvmipra, 8]]] https://reviews.llvm.org/D23980
* [[[picorvint, 9]]] https://github.com/YosysHQ/picorv32#custom-instructions-for-irq-handling
* [[[bhvseabi, 10]]] https://groups.google.com/a/groups.riscv.org/g/sw-dev/c/znKeVnmxsy8/m/NtdDII3kAAAJ
* [[[pushint, 11]]] https://github.com/riscv/riscv-fast-interrupt/issues/108
* [[[thead, 12]]] https://github.com/T-head-Semi/thead-extension-spec
* [[[armnvic, 13]]] https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/beginner-guide-on-interrupt-latency-and-interrupt-latency-of-the-arm-cortex-m-processors
* [[[spracs0a, 14]]] https://www.ti.com/lit/an/spracs0a/spracs0a.pdf?ts=1677348911359&ref_url=https%253A%252F%252Fduckduckgo.com%252F
* [[[ticladocs, 15]]] https://software-dl.ti.com/C2000/docs/cla_software_dev_guide/intro.html
* [[[emblinux, 16]]] https://jaycarlson.net/embedded-linux/
* [[[linuxrt1, 17]]] https://elinux.org/images/d/de/Real_Time_Linux_Scheduling_Performance_Comparison.pdf
* [[[linuxrt2, 18]]] https://static.lwn.net/lwn/images/conf/rtlws11/papers/proc/p19.pdf
* [[[linuxrt3, 19]]] https://people.mpi-sws.org/~bbb/papers/pdf/ospert13.pdf
* [[[linuxrt4, 20]]] https://www.osadl.org/fileadmin/events/rtlws-2007/Siro.pdf
