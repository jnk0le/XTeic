
= riscv-total-embedded
Jan Oleksiewicz <jnk0le@hotmail.com>
:appversion: 0.1.1
:toc:
:toclevels: 4
:sectnums:


{author} {email} +
document version {appversion} +
extension status: unstable/PoC +
This document is released under a Creative Commons Attribution 4.0 International License

[colophon]
== revision history


[colophon]
== preface

This document uses semantic versioning with respect to potential hardware designs. 
Assembly syntax change is a minor increment. Version 1.0.0 is the first publicly released. 
Changes in prior versions are not versioned properly and not tracked in revision history.

Document is written in a way that reduces the duplications as those are hard to maintain.

== Introduction

even though is great for unix interrupts 

instead of adding more and more on top of legacy interrupt architecture

replace volume II (aka riscv privileged)


achieve 0 jitter, single digit cycles of interrupt latency (to actual code)

=== prior art

A quick recap of what we already have.

==== cortex-m NVIC

An "industry standard"

==== CLIC

<<clic>>

==== emb-riscv

<<embriscv>>

clean sheet designs
attempts to be

=== CLINT

Attaches to generic interrupt scheme.

According to <<clint>>, it provides memory mapped interface for timers and IPI.

==== generic riscv interrupts as described in "privileged" volume II 

Very often refered to as CLINT. e.g. <<sififeintcookbook>> indirectly claims that volume II 
stuff is CLINT exclusive.

Doesn't provide any nesting other than privilege levels
Registers and CSR state (`fcsr` etc.) have to be pushed by software before use

==== PLIC/AIA

a heavyweight frontend for delivering interrupts to multiple cores 
running typical unix OS. Not suitable for microcontrolers.

handlers stay very similar to generic case.

=== overwiew of some concepts/features

==== whole app doable in C/C++

Interrupts must always push all caller saved registers to be able to use functions without 
`__attribute__((interrupt))` annotation.

NOTE: those are usually wrapped with `extern "C" anyway

It also requires preinitialized table with pointer to startup code, `sp`, and `gp`, and of course
any other addition like Zcmt `JVT` csr. A bit of added complexity.

It is also not necessarily smaller than software setup, e.g. `sp` can be usually
done with single `lui` instruction.

Of course I often find that there is a competition on who will make
the worst startup code in assembly. 
So pure C/C++ startup code turns out to be "better" due to confirmation effect.
But let's have a look at my "combotablecrt" implementation <<combotablecrt>> for stm32f030x4/6. 
Is your compiler able to do that?

There is also a case of interrupt handlers that are using 
and don't need to take latency of 

==== ABIs with less caller saved registers

==== trying to be too universal

great flexibility comes with great inefficiencies.

==== handler return pattern

NVIC and emb-riscv

==== vector tables containing jump instructions

==== memory mapped vs CSR mapped configuration


=== required ABI

get rid of `tp` register

==== RV32E

==== RV32I


=== tooling issues to solve

==== prestacked annotation 

==== IPRA

in llvm


== programmers model
//?????
//non profile ext

//common
	//optional tiny vect table

//profiles
//tiny
	//limited features
	//??

//medium

[appendix]
== appendix


[bibliography]
== Bibliography

* [[[embriscv, 1]]] https://github.com/emb-riscv/specs-markdown
* [[[clic, 2]]] https://github.com/riscv/riscv-fast-interrupt/blob/master/clic.adoc
* [[[clint, 3]]] https://github.com/riscv/riscv-aclint/blob/main/riscv-aclint.adoc
* [[[sififeintcookbook, 4]]] https://starfivetech.com/uploads/sifive-interrupt-cookbook-v1p2.pdf
* [[[plic, 5]]] https://github.com/riscv/riscv-plic-spec
* [[[aia, 6]]] https://github.com/riscv/riscv-aia
* [[[combotablecrt, 7]]] https://github.com/jnk0le/simple-crt/blob/master/cm0/combotablecrt_stm32f030x6.S