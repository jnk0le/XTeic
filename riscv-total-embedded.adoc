
= riscv-total-embedded
Jan Oleksiewicz <jnk0le@hotmail.com>
:appversion: 0.1.10
:toc:
:toclevels: 4
:sectnums:


{author} {email} +
document version {appversion} +
extension status: unstable/PoC +
This document is released under a Creative Commons Attribution 4.0 International License

[colophon]
== revision history


[colophon]
== preface

This document uses semantic versioning with respect to potential hardware designs. 
Assembly syntax change is a minor increment. Version 1.0.0 is the first publicly released. 
Changes in prior versions are not versioned properly and not tracked in revision history.

Document is written in a way that reduces the duplications as those are hard to maintain.

== Introduction

Even though the current risc-v interrupt architecture is great for unix sustems.
It fails to meet many embedded and hard real time requirements.

Instead of adding more and more on top of layered legacy, let's replace
entire volume II (aka riscv privileged) with minimal yet efficient interrupt architecture.

The goal is to achieve single digit cycles of interrupt latency (to actual code) with minimal jitter.

=== prior art

A quick recap of what we already have available.

==== cortex-m NVIC

<<armnvic>> defacto established "industry standard" of efficient interrupt handling.
Anyone complaining about risc-v likes and wants the NVIC.

==== CLIC

<<clic>> is a designated goto for interrupt handling to fulfill everyone needs.
Development took long enough to achieve pre-freeze implementations by some chinese vendors.

Attempts to be an unix compatible interrupt controller with horizontal nesting of U, S and M mode. (including U mode interrupts)

preemption is handled in software 

preemption 
(even in inline handlers)



handlers divided into inline and trampoline dispathced ones

introduces concept of
C function dispatcher/trampoline
very long latency to actual instruction
late arrival `mnxti`
high jitter


NOTE: BTW, my prediction is that the "competitor A" will be able to do a 
"comparison against riscv" without resorting to FUD tactics, right after CLIC is ratified

==== emb-riscv

<<embriscv>> is clean sheet designs
that attempts to be too universal

lot of redundancy
U+M
separate tables for exceptions and interrupts

mandatory 64bit cycle counter
mandatory 64bit instret counter
mandatory 64bit system timer
mandatory 64bit rtc timer

NOTE: Y2038 can be solved by less than 32 extra bits, even simple uint32_t trick gives us extra ~68 years.
Many RTC implementations are also BCD or BCD like with e.g. separate uint8_t fields for seconds, minutes, day, year etc.

currently development stalled

==== CLINT

Attaches to generic interrupt scheme.

According to <<clint>>, it provides memory mapped interface for timers and IPI.

NOTE: ofiicial CLINT is callet ACLINT but doesn't differ much from CLINT in sifive documentations.

==== generic riscv interrupts as described in "privileged" volume II 

Very often refered to as CLINT. e.g. <<sififeintcookbook>> indirectly claims that volume II 
stuff is CLINT exclusive.

has vectored mode which simply jumps to the position in vector table.

Doesn't provide any nesting other than privilege levels
Registers and CSR state (`fcsr` etc.) have to be pushed by software before use

==== PLIC/AIA

<<plic>>, <<aia>>

A heavyweight frontend for delivering interrupts to multiple cores 
running typical unix OS. Not suitable for microcontrolers.

claim/complete architecture

handlers stay very similar to generic case.

==== CH32 FPIC/PFIC



undocumented "EABI" mode (except just the presence of it)


inherits behaviour/patterns of 

==== PicoRV32 interrupts

> Note: The IRQ handling features in PicoRV32 do not follow the RISC-V Privileged ISA specification.
> Instead a small set of very simple custom instructions is used to implement IRQ handling with minimal hardware overhead.

Original author of the PicoRV found the riscv-privileged to be too heavy for minimal core,
and provided own <<picorvint>> interrupt scheme.

=== overwiew/discussion of some concepts/features

==== whole app must be doable in C/C++

In this case interrupts must always push all caller saved registers to be able to use functions without 
`\\__attribute__\((interrupt*))` annotation.

NOTE: those are usually wrapped with `extern "C"` anyway

It also requires preinitialized table with pointer to startup code, `sp`, and `gp`, and of course
any other addition like Zcmt `JVT` csr.

This table is also not necessarily smaller than software setup, e.g. `sp` can be usually
done with single `lui` instruction. At the cost of a bit added HW complexity.

There is still a risk of corruption if the compiler decides to reorder something before
initialization of `.data`/`.bss` sections.

Of course I often find that there is a competition on who will make
the worst startup code in assembly. 
So pure C/C++ startup code turns out to be "better" due to confirmation effect.
But let's have a look at my "combotablecrt" implementation <<combotablecrt>> for stm32f030x4/6. 
Is your compiler able to do that?

There is also a case of interrupt handlers that are using only a few registers
and don't need to take latency of the whole ABI.

==== ABIs with less caller saved registers

The rationale of introducing ABIs with reduced number of caller saved registers is to 
reduce interrupt latency. 

The major downside of such approach is lowered overall performance 
and code denisty. Which is highly unliked across riscv community <<bhvseabi>> and stalls 
development of such (E)ABI.

> I think for marketing reasons we should have the RISC-V EABI mimic the competitor ABI as 
> closely as possible, and be available and supported by the tools, even if almost no-one 
> should end up actually using it.

Zcmp[e] was also prepared for such fragmentation by reserving first 4 points in rlist for EABI,
so the cores can implement UABI and EABI push/pop instructions at the same time.
Those 4 points are of course supposed to handle 20 caller saved regs of EABI (probably with some 
reuse of few higher points).

It will also make the processors capable of stacking 2 registers per cycle, underutiized
during HW stacking due to shorter stacking time than pipeline refill.

An alternative is to provide interrupts with defacto customizable ABIs by e.g. <<prestacked annotation>>
(to match the HW stackers) and handle the function call pressure by <<IPRA>>.

==== "you are better of with soft stacking in inline handlers"

aka generic riscv `\\__attribute__\((interrupt))`

First major issue is decreased code density due to all of the stacking code.

Compilers also barely care about optimizing for register pressure in interrupts.
The prologues/epilogues seem to be completely transparent for code generation.
Which is especially visible in cases where majority of the prologue/epilogue code could 
be easily conditionally skipped, but compilers simply don't do it.
(just the loads/stores, stack can be fully preallocated on entry)

NOTE: avr8-gcc for a very long time was emitting useless prologues/epilogues for pushing `SREG`, `r0`, `r1` and clearing `r1`
even though those were not affected or used by ISR code. Of course the version that finally fixed it, was never 
shipped in Atmel Studio.

NOTE: Zcmp[e] doesn't cover caller saved registers except `ra`.

The other one is one of the principles of hardware stackers.

When entering interrupt handler, the core first fetches the entry from vector table and then
jumps to that address. Both of those fetches can hit a flash waitstate or a cache miss.
During that operation the data bus remains idle waiting for a first store instruction to be executed.

Those cycles can be accomodated for a "free" stacking of registers. If a higher amount of
registers is stacked then it can hide a bit of jitter coming from cache misses or flash waitstates.

Even stacking by the special push instructions (e.g. XTheadInt <<thead>> or
PUSHINT <<pushint>> and maybe a subsets of those), won't help much. Those start pushing
after the latency of double (waitstated) miss was taken.

==== EABI for RVE must be subset of RVI EABI

to be able to call RVE only code from RVI ABI

common in eabi proposals
static compiled


the idea is to provide precompiled libraries
code arbitrarily compiled for RVE might turn out to be less efficient than

limits the rvi capbilities (extra/trading a regs instead of T)


==== one universal for everyones use cases

high flexibility
causes redundancy
waste of

==== handler return pattern

NVIC and emb-riscv

==== vector tables containing jump instructions

supposedly

works in classic ARM FIQ, and 8051 assembly

==== memory mapped vs CSR mapped configuration

in case of mass initialization

==== trampoline 

introduced by CLIC



==== "zero jitter"

can be claimed
"late arrival" and "pop pre-emption" is responsible

=== required ABI

ideally not change
avoid disruption

but may need

definitely get rid of `tp` register, it's useless here.

==== RV32E

==== RV32I

==== stack alignment



=== tooling issues to solve

==== prestacked annotation

//e.g. `tp` cannot be changed to caller saved due to existing hardware pre-stackers (ch32)

==== IPRA

in llvm <<llvmipra>>

in simple explanation



very little information foundable can be googled
mostly llvm 

even if there is something benchmarked
of course -O3 (forget about -Os and -Oz)



//???===== regression due to

==== automatic selection of regpush on isr entry config

== programmers model
//?????
//non profile ext

//common
	//optional tiny vect table

//profiles
//tiny
	//limited features
	//??

//medium

[appendix]
== appendix


[bibliography]
== Bibliography

* [[[embriscv, 1]]] https://github.com/emb-riscv/specs-markdown
* [[[clic, 2]]] https://github.com/riscv/riscv-fast-interrupt/blob/master/clic.adoc
* [[[clint, 3]]] https://github.com/riscv/riscv-aclint/blob/main/riscv-aclint.adoc
* [[[sififeintcookbook, 4]]] https://starfivetech.com/uploads/sifive-interrupt-cookbook-v1p2.pdf
* [[[plic, 5]]] https://github.com/riscv/riscv-plic-spec
* [[[aia, 6]]] https://github.com/riscv/riscv-aia
* [[[combotablecrt, 7]]] https://github.com/jnk0le/simple-crt/blob/master/cm0/combotablecrt_stm32f030x6.S
* [[[llvmipra, 8]]] https://reviews.llvm.org/D23980
* [[[picorvint, 9]]] https://github.com/YosysHQ/picorv32#custom-instructions-for-irq-handling
* [[[bhvseabi, 10]]] https://groups.google.com/a/groups.riscv.org/g/sw-dev/c/znKeVnmxsy8/m/NtdDII3kAAAJ
* [[[pushint, 11]]] https://github.com/riscv/riscv-fast-interrupt/issues/108
* [[[thead, 12]]] https://github.com/T-head-Semi/thead-extension-spec
* [[[armnvic, 13]]] https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/beginner-guide-on-interrupt-latency-and-interrupt-latency-of-the-arm-cortex-m-processors