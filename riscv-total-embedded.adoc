
= riscv-total-embedded
Jan Oleksiewicz <jnk0le@hotmail.com>
:appversion: 0.1.28
:toc:
:toclevels: 4
:sectnums:


{author} {email} +
document version {appversion} +
extension status: unstable/PoC +
This document is released under a Creative Commons Attribution 4.0 International License

[colophon]
== revision history


[colophon]
== preface

This document uses semantic versioning with respect to potential hardware designs. 
Assembly syntax change is a minor increment. Version 1.0.0 is the first publicly released. 
Changes in prior versions are not versioned properly and not tracked in revision history.

Document is written in a way that reduces the duplications as those are hard to maintain.

== Introduction

Even though the current risc-v "privileged" architecture is great for general unix systems.
It fails to meet many embedded and hard real time requirements.

Instead of adding more and more on top of layered legacy, that leads to silicon waste, let's replace
entire volume II (aka riscv privileged) with minimal yet efficient embedded architecture.

The goal is to achieve interrupt architecture capapble of predictable and low latency
control loops by providing minimal jitter and interrupt latency. +
Optionally offer single digit cycles of interrupt latency to actual code and true zero jitter,
as to not disturb minimal implementations. +
By leveraging general purpose computing capability of risc-v architecture, we can
avoid the need for separate cores (with asymetric architecture) to offload communication tasks etc.

=== prior art

A quick recap of what we already have available.

==== cortex-m NVIC

<<armnvic>> defacto established "industry standard" of efficient interrupt handling.
Anyone complaining about risc-v likes and wants the NVIC.

==== CLIC

CLIC <<clic>> is a designated goto for interrupt handling to fulfill everyone needs.
Development took long enough to achieve pre-freeze implementations by some chinese vendors.

Attempts to be an unix capable interrupt controller with horizontal nesting of U, S, H (so far only proposed) and M mode.

All used registers must be saved in software, trampoline handlers need to save all ABI registers.

Preemption is handled in software by special CSR mechanism, that requires extra boilerplate
code in every interrupt handler. Even in "inline" handlers.

Highest priority inline handlers are similar to legacy ones.

Introduces unavoidable jitter due to:

- blocks of code executed with disabled interrupts (additive jitter)
- late arrival handled through mnxti read (subtractive jitter of entry time)
- tail chaining handled by another mnxti read (and extra branch) in epilogue
- indirect jump instruction to actual code (branch prediction)

assuming 1 cycle per instruction, 10.2 and 11.1 listings from clic spec <<clic>> offer:

- `entry + 6` cycles of jitter from "inline" handlers.
- `entry + 7 + 16` cycles of jitter from "C-ABI" trampoline entry
- `4` or `abs(entry - 7)` cycles of jitter from  "C-ABI" trampoline epilogue

NOTE: the trampoline doesn't need to stack all of the 16 caller saved registers before enabling
interrupts, but this exact code is about to be pushed down your throat anyway.

NOTE: according to <<clicentrycycles>>, handler entry time is 6 cycles on sifive E2 and
10 cycles in E3/5

NOTE: BTW, my prediction is that the "competitor A" will be able to do a 
"comparison against riscv" without resorting to FUD tactics, right after CLIC is ratified

==== emb-riscv

emb-riscv <<embriscv>> is clean sheet design that attempts to be universal solution 
for every microcontroller. Designed with a strong focus on RTOS support.

NOTE: Currently development is stalled due to "not encouraging general interest"

Achieves lower interrupt latency by introducing EABI with reduced
amount of caller-saved registers. FP registers are handled by lazy stacking.

Introduces interrupt priority threshold masking.

mandates 4 64bit timers (even on RV32):
- cycle counter
- instret counter
- system timer
- rtc timer

==== CLINT

Attaches to generic interrupt scheme.

According to <<clint>>, it provides memory mapped interface for timers and IPI.

NOTE: ofiicial CLINT is callet ACLINT but doesn't differ much from CLINT in sifive documentations.

==== generic riscv interrupts as described in "privileged" volume II 

Very often refered to as CLINT. e.g. <<sififeintcookbook>> claims that volume II 
stuff is CLINT exclusive.

has vectored mode which simply jumps to the position in vector table.

Doesn't provide any nesting other than privilege levels
Registers and CSR state (`fcsr` etc.) have to be pushed by software before use

==== PLIC/AIA

<<plic>>, <<aia>>

A heavyweight frontend for delivering interrupts to multiple cores 
running typical unix OS. Not suitable for microcontrolers.

claim/complete architecture

handlers stay very similar to generic case.

==== CH32 PFIC

Proprietary design by WCH build on top of generic riscv privileged <<qingkev2>>, <<qingkev3>>, <<qingkev4>>.

The descriptions of a lot of functional behaviour feel like a copy-paste of risc-v privileged.
Highly under/undocumented. +
e.g. there is nothing about what happens to `mepc`, `mcause` or `mstatus` during nesting (especially on "V2" core).

The vendor provided headers, of course, contain 46 instances of "NVIC" string and just 5 for "PFIC"

Introduces HW stacking or single cycle register shadowing (aka HPE).
It is of course necessary to use custom tuoolchain that implement a "proprietary" attribute:: 
`\\__attribute__\(((interrupt("WCH-Interrupt-fast"))`

NOTE: without <<prestacked annotation>> there will be no portable way of doing this, naked 
handler + mret trick doesn't work in llvm, it  shoud break in gcc anyway due to use of callee saved registers.

There is also under/undocumented "EABI enable" bit in `INTSYSCR` on "V2" core.
Most probably it reduces number of HW stacked registers to match the official EABI proposal <<riscveabi>>.

==== PicoRV32 interrupts

> Note: The IRQ handling features in PicoRV32 do not follow the RISC-V Privileged ISA specification.
> Instead a small set of very simple custom instructions is used to implement IRQ handling with minimal hardware overhead.

Original author of the PicoRV found the riscv-privileged to be too heavy for minimal core,
and provided own <<picorvint>> interrupt scheme.

NOTE: FPGA minimum cores, is a non goal for this spec

==== ti c2000 (main core)

Proprietary TI architecture <<spru430>> sporting an ancient accumulator-memory architecture (with 8 pointer registers),
similar to the classic CISCs. An x86 of motor control and signal processing.
FPU <<spruhs1c>> is more RISC-ish with a bit of VLIW in some instructions.

NOTE: TI is very hesitant to release any general purpose benchmark scores (speed/size etc.) 
<<c2000coremark>>, <<c2000dhrystone>>. Claiming that their architecture "is optimized for
real world control applications". Those kind of scores are also almost non existent in independent sources.

According to <<spraan9a>>, the core automatically saves some of the registers, rest must be pushed
in software. +
"High priority" interrupts can also save floating point registers into shadow registers using 
special instructions. +
There are also 5 (4 in prologue) defacto useless instructions for aligning stack and setting "C28 modes"

To allow nesting of "low priority" interrupts handlers must include extra boilerplate code to
handle prioritiy masking in software. (8 instructions in prologue, 3 in epilogue)

As a consequence there is 21 cycles of jitter and 43 (HPI) or 63 (LPI) cycles of interrupt latency in worst case.

Use of RPT istruction will introduce even more jitter and latecy as the sequence is uninterruptible
and takes arbitrary numbers of cycles to execute.

NOTE: ISR entry latency is 10 cycles due to 8 stage pipeline and automatically stacking 13 registers.

=== overwiew/discussion of some concepts/features

==== whole app must be doable in C/C++

In this case interrupts must always push all caller saved registers to be able to use functions without 
`\\__attribute__\((interrupt*))` annotation. Leading to <<ABIs with less caller saved registers>>

NOTE: those are usually wrapped with `extern "C"` anyway

It also requires preinitialized table with pointer to startup code, `sp`, `gp`, and of course
any other addition like Zcmt `JVT` csr.

This table is also not necessarily smaller than software setup, e.g. `sp` can be usually
done with single `lui` instruction.

There is still a risk of corruption if the compiler decides to reorder something before
initialization of `.data`/`.bss` sections.

Of course I often find that there is a competition on who will make
the worst startup code in assembly. 
So pure C/C++ startup code turns out to be "better" due to confirmation effect.
But let's have a look at my "combotablecrt" implementation <<combotablecrt>> for stm32f030x4/6. 
Is your compiler able to do that?

There is also a case of interrupt handlers that are using only a few registers
and don't need to take latency of the whole ABI.

==== ABIs with less caller saved registers

The rationale of introducing ABIs with reduced number of caller saved registers is to 
reduce interrupt latency. 

The major downside of such approach is lowered overall performance 
and code denisty. Which is highly unliked across riscv community <<bhvseabi>> and stalls 
development of such (E)ABI.

> I think for marketing reasons we should have the RISC-V EABI mimic the competitor ABI as 
> closely as possible, and be available and supported by the tools, even if almost no-one 
> should end up actually using it.

Zcmp[e] was also prepared for such fragmentation by reserving first 4 points in rlist for EABI,
so the cores can implement UABI and EABI push/pop instructions at the same time.
Those 4 points are of course supposed to handle 20 caller saved regs of EABI (probably with some 
reuse of few higher points).

It will also make the processors capable of stacking 2 registers per cycle, underutilized
during HW stacking due to shorter stacking time than pipeline refill.

An alternative is to provide interrupts with defacto customizable ABIs by e.g. <<prestacked annotation>>
(to match the HW stackers) and handle the function call pressure by <<IPRA>>.

==== "you are better of with soft stacking in inline handlers"

aka generic riscv `\\__attribute__\((interrupt))`

First major issue is decreased code density due to all of the stacking code.

Compilers also barely care about optimizing for register pressure in interrupts.
The prologues/epilogues seem to be completely transparent for code generation.
Which is especially visible in cases where majority of the prologue/epilogue code could 
be easily conditionally skipped, but compilers simply don't do it.
(just the loads/stores, stack can be fully preallocated on entry)

NOTE: avr8-gcc for a very long time was emitting useless prologues/epilogues for pushing `SREG`, `r0`, `r1` and clearing `r1`
even though those were not affected or used by ISR code. Of course the version that finally fixed it, was never 
shipped in Atmel Studio.

NOTE: Zcmp[e] doesn't cover caller saved registers except `ra`.

The other one is one of the principles of hardware stackers.

When entering interrupt handler, the core first fetches the entry from vector table and then
jumps to that address. Both of those fetches can hit a flash waitstate or a cache miss.
During that operation the data bus remains idle waiting for a first store instruction to be executed.

Those cycles can be accomodated for a "free" stacking of registers. If a higher amount of
registers is stacked then it can hide a bit of jitter coming from cache misses or flash waitstates.

Even stacking by the special push instructions (e.g. XTheadInt <<thead>> or
PUSHINT <<pushint>> and maybe a subsets of those), won't help much. Those start pushing
after the latency of double (waitstated) miss was taken.

==== EABI for RVE must be subset of RVI EABI.

To be able to call RVE only code from RVI ABI +
Recurrig thing in RVE ABI proposals.

The idea is to allow compilers and software vendors to provide a single
set of precompiled libraries for RVI and RVE ABIs.

The issue with this approach is that the code arbitrarily compiled for RVE 
might turn out to be less efficient than RVI one. It also limits the capabilities
of RVI ABI like trading off argument registers for temporary/saved ones.

==== one universal standard for everyone use cases

Having one universal solution for all possible configs
brings a lot of inefficiency to all of them. Due to mandatory 
support for a lot of useless functionality, or just the need 
to keep optional compatibility with useless legacy "just in case".

==== special handler return pattern

aka "HANDLER_RETURN" on emb-riscv and "EXC_RETURN" on ARM

The idea is to put special pattern in `ra` during handler entry and
exit by reusing regular return mechanism provided by the ABI. Requires 
certain memory area to be non executable (e.g. 0xF0000000 - 0xFFFFFFFF)

This mechanism follows the typical ABI function call and together with HW 
stacking, allows the interrupt handlers to be a regular C functions.

The downside is that the `ra` and `pc` both have to be pushed onto stack
and in some specifc cases, it could add extra stall cycles after the tail due
to the waitstates/cache miss caused by delayed prefetch.

Alternatively we can just stack the `ra` and put there current `pc` with lowest bit set 
to trigger handler return operation. One less register counted towards interrupt latency.

NOTE: normally the `jalr` instruction just ignores the LSB bit of resulting address.
LSB in register and immediate will lead to "bogus" jump over 2 extra bytes.
Even though this behaviour simplifies hardware, it was oversighted in ABI design 
by allowing "auxiliary information" in pointers as well as `jalr` 
immediate, effectively making both useless.

==== vector tables containing jump instructions

It's simply inefficient in truly vectored scenario.
The vector entries will have to be populated with jump instructions anyway.
Those have to take the second round of waitstates/cache miss without amortization by register stacking.

And if the code is far away from vector table (e.g. in SRAM for more deterministic execution),
compiler will have to emit a jump island, aka "veener", that will perform yet another unamortized jump.
allocating 8 bytes per entry and enforcing `lui` + `jalr` sequence will severly trump the 
code density and performance in typical use scenarios.

NOTE: 8051 allocated 8 bytes per entry, but it was able to sometimes fit entire handler or
one of the conditional path. Especially when following entries were unused. This kind of 
optimizations is exlusive to assmebly programming and not practised today.

==== MMIO vs CSR mapped config registers

In case of mass initialization MMIO could result in better code density
CSR space is also limited.

My take is that anything architecturally coupled to the core should reside 
in CSR space and keep the rest in MMIO.

Nothing should exist as both.

==== "reduced/zero jitter"

Very often claimed, yet those claims rarely meet with reality.

NOTE: There are also meany non-architectural sources of jitter like caches, waitstated
flash or accessing peripherals in different clock domains (usually divided from sysclk).

Cortex-m0 offers a "zero jitter" by optional IP configuration that adjusts the best case 
of interrupt latency by extra cycle to acommodate random stall from bus contention.

Cortex-m3/4 offer up to 6 cycles of jitter due to "late arrival" and "pop pre-emption".
Regular handler entry is dominated by stacking registers, giving some headroom for extra
vector/instruction fetch latency.

Cortex-cm7 of course suffers from Proprietary&Confidential syndrome. 
Most probably it's similar to cm3/4.

In case of C2000 CLA, TI claims <<spracs0a>>,<<ticladocs>>,<<ticladevguide>> that their task driven machine 
(non preemptible) "reduces interrupt latency and jitter" compared to classic CPU, even
though it does exactly the opposite when there is more than 1 async interrupt to handle.

NOTE: Of course whenever TI compares CLA to "classic cpu", it's always a cpu with preemption 
priority only and background task not present on CLA. As if the similar "task machine" couldn't
be achieved by regular cpu (e.g. risc-v) without nesting and WFI loop (or "sleep on exit" feature) 
giving access to all GPRs in interrupts without stacking.

==== "everything will run Linux in future"

The Linux cargo cult. +
Because a simplest tasks suitable for bunch of 555&74s or a simple microcontroler with a 
few KiB of flash and RAM must be done under linux so it will work somehow "better".

To be able to properly run linux you need quite beefy cpu with a proper MMU, 2-4MiB of flash, 
4-8MiB of RAM (usually external DRAM), long boot time and a bad power consumption in idle. +
Just to run the OS itself.

One of the the most blatant example is NOMMU linux on stm32f429 with SDRAM that is not cached by cpu.

Of course there are actual reasons <<emblinux>> to use linux in embedded.

===== RTLinux and hard-realtime

Whenever those rt patches are measured, both the interrupt latency and 
jitter is always given in microseconds (10-100), not cycles
<<linuxrt1>>,<<linuxrt2>>,<<linuxrt3>>,<<linuxrt4>>.

In some scenarios those numbers are unacceptable.

==== lazy stacking

Lazy stacking allows to skip stacking of FP registers if handler doesn't 
touch floating point registers.

The main issue is that all of the caller saved FP registers are saved (execution stalls during push)
onto stack whenever FP instruction is executed even though only a few of the registers are used.

==== 64bit microcontrollers

So far, mostly the application processors used in bare metal.

Use cases for such also have different requirements than
from typical 32bit microcontrollers.

=== required ABI

ideally not change
avoid disruption

but may need

definitely get rid of `tp` register, it's useless here.

==== RV32E

==== RV32I

==== stack alignment



=== tooling issues to solve

==== prestacked annotation

//e.g. `tp` cannot be changed to caller saved due to existing hardware pre-stackers (ch32)

==== IPRA

in llvm <<llvmipra>>

in simple explanation



very little information foundable can be googled
mostly llvm 

even if there is something benchmarked
of course -O3 (forget about -Os and -Oz)



//???===== regression due to

==== automatic selection of regpush on isr entry config

== programmers model

//?????
//non profile ext
//little endian only

//common
	//optional tiny vect table

//profiles
//tiny
	//limited features
	//??

//medium
//sec

[appendix]
== context switch on tiny profile


[bibliography]
== Bibliography

* [[[embriscv, 1]]] https://github.com/emb-riscv/specs-markdown
* [[[clic, 2]]] https://github.com/riscv/riscv-fast-interrupt/blob/master/clic.adoc
* [[[clint, 3]]] https://github.com/riscv/riscv-aclint/blob/main/riscv-aclint.adoc
* [[[sififeintcookbook, 4]]] https://starfivetech.com/uploads/sifive-interrupt-cookbook-v1p2.pdf
* [[[plic, 5]]] https://github.com/riscv/riscv-plic-spec
* [[[aia, 6]]] https://github.com/riscv/riscv-aia
* [[[combotablecrt, 7]]] https://github.com/jnk0le/simple-crt/blob/master/cm0/combotablecrt_stm32f030x6.S
* [[[llvmipra, 8]]] https://reviews.llvm.org/D23980
* [[[picorvint, 9]]] https://github.com/YosysHQ/picorv32#custom-instructions-for-irq-handling
* [[[bhvseabi, 10]]] https://groups.google.com/a/groups.riscv.org/g/sw-dev/c/znKeVnmxsy8/m/NtdDII3kAAAJ
* [[[pushint, 11]]] https://github.com/riscv/riscv-fast-interrupt/issues/108
* [[[thead, 12]]] https://github.com/T-head-Semi/thead-extension-spec
* [[[armnvic, 13]]] https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/beginner-guide-on-interrupt-latency-and-interrupt-latency-of-the-arm-cortex-m-processors
* [[[spracs0a, 14]]] https://www.ti.com/lit/an/spracs0a/spracs0a.pdf?ts=1677348911359&ref_url=https%253A%252F%252Fduckduckgo.com%252F
* [[[ticladocs, 15]]] https://software-dl.ti.com/C2000/docs/cla_software_dev_guide/intro.html
* [[[emblinux, 16]]] https://jaycarlson.net/embedded-linux/
* [[[linuxrt1, 17]]] https://elinux.org/images/d/de/Real_Time_Linux_Scheduling_Performance_Comparison.pdf
* [[[linuxrt2, 18]]] https://static.lwn.net/lwn/images/conf/rtlws11/papers/proc/p19.pdf
* [[[linuxrt3, 19]]] https://people.mpi-sws.org/~bbb/papers/pdf/ospert13.pdf
* [[[linuxrt4, 20]]] https://www.osadl.org/fileadmin/events/rtlws-2007/Siro.pdf
* [[[clicentrycycles, 21]]] https://riscv.org/wp-content/uploads/2018/07/DAC-SiFive-Drew-Barbier.pdf
* [[[spraan9a, 22]]] https://www.ti.com/lit/an/spraan9a/spraan9a.pdf?ts=1677877354340
* [[[spru430, 23]]] https://www.ti.com/lit/ug/spru430f/spru430f.pdf?ts=1677869437551&ref_url=https%253A%252F%252Fwww.google.com%252F
* [[[spruhs1c, 24]]] https://www.ti.com/lit/ug/spruhs1c/spruhs1c.pdf?ts=1677888169020&ref_url=https%253A%252F%252Fwww.google.com%252F
* [[[c2000coremark, 25]]] https://e2e.ti.com/support/processors-group/processors/f/processors-forum/905744/tms320f28335
* [[[c2000dhrystone, 26]]] https://e2e.ti.com/support/microcontrollers/c2000-microcontrollers-group/c2000/f/c2000-microcontrollers-forum/567535/tms320f28377d-dmips-calculation
* [[[ticladevguide, 27]]] https://software-dl.ti.com/C2000/docs/cla_software_dev_guide/_static/pdf/C2000_CLA_Software_Development_Guide.pdf
* [[[qingkev2, 28]]] http://www.wch-ic.com/downloads/QingKeV2_Processor_Manual_PDF.html
* [[[qingkev3, 29]]] http://www.wch-ic.com/downloads/QingKeV3_Processor_Manual_PDF.html
* [[[qingkev4, 30]]] http://www.wch-ic.com/downloads/QingKeV4_Processor_Manual_PDF.html
* [[[riscveabi, 31]]] https://github.com/riscv-non-isa/riscv-eabi-spec