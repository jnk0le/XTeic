
= riscv-total-embedded
Jan Oleksiewicz <jnk0le@hotmail.com>
:appversion: 0.1.8
:toc:
:toclevels: 4
:sectnums:


{author} {email} +
document version {appversion} +
extension status: unstable/PoC +
This document is released under a Creative Commons Attribution 4.0 International License

[colophon]
== revision history


[colophon]
== preface

This document uses semantic versioning with respect to potential hardware designs. 
Assembly syntax change is a minor increment. Version 1.0.0 is the first publicly released. 
Changes in prior versions are not versioned properly and not tracked in revision history.

Document is written in a way that reduces the duplications as those are hard to maintain.

== Introduction

even though 

is great for unix interrupts

it fails to meet 

embedded/hard real time requirements


instead of adding more and more on top of legacy interrupt scheme, trying to be 
compatible with everything

let's
replace volume II (aka riscv privileged)

with minimal yet efficient

the goal is to
achieve 0 jitter, single digit cycles of interrupt latency (to actual code)

=== prior art

A quick recap of what we already have.

==== cortex-m NVIC

defacto established "industry standard" of efficient interrupt handling.
Anyone complaining about risc-v likes the NVIC.

==== CLIC

<<clic>> is a designated goto for interrupt handling to fulfill everyone needs.
Development took long enough to achieve pre-freeze implementations by some chinese vendors.

Attempts to be an unix compatible interrupt controller with horizontal nesting of U, S and M mode. (including U mode interrupts)

preemption is handled in software 

preemption 
(even in inline handlers)



handlers divided into inline and trampoline dispathced ones

introduces concept of
C function dispatcher/trampoline
very long latency to actual instruction
late arrival `mnxti`
high jitter




==== emb-riscv

<<embriscv>> is clean sheet designs
that attempts to be too universal

lot of redundancy
U+M
separate tables for exceptions and interrupts

mandatory 64bit cycle counter
mandatory 64bit instret counter
mandatory 64bit system timer
mandatory 64bit rtc timer

NOTE: Y2038 can be solved by less than 32 extra bits, even simple uint32_t trick gives us extra ~68 years.
Many RTC implementations are also BCD or BCD like with e.g. separate uint8_t fields for seconds, minutes, day, year etc.

currently development stalled

==== CLINT

Attaches to generic interrupt scheme.

According to <<clint>>, it provides memory mapped interface for timers and IPI.

NOTE: ofiicial CLINT is callet ACLINT but doesn't differ much from CLINT in sifive documentations.

==== generic riscv interrupts as described in "privileged" volume II 

Very often refered to as CLINT. e.g. <<sififeintcookbook>> indirectly claims that volume II 
stuff is CLINT exclusive.

has vectored mode which simply jumps to the position in vector table.

Doesn't provide any nesting other than privilege levels
Registers and CSR state (`fcsr` etc.) have to be pushed by software before use

==== PLIC/AIA

<<plic>>, <<aia>>

A heavyweight frontend for delivering interrupts to multiple cores 
running typical unix OS. Not suitable for microcontrolers.

claim/complete architecture

handlers stay very similar to generic case.

==== CH32 FPIC/PFIC



undocumented "EABI" mode (except just the presence of it)


inherits behaviour/patterns of 

==== PicoRV32 interrupts

> Note: The IRQ handling features in PicoRV32 do not follow the RISC-V Privileged ISA specification.
> Instead a small set of very simple custom instructions is used to implement IRQ handling with minimal hardware overhead.

Original author of the PicoRV found the riscv-privileged to be too heavy for minimal core,
and provided own <<picorvint>> interrupt scheme.

=== overwiew/discussion of some concepts/features

==== whole app must be doable in C/C++

In this case interrupts must always push all caller saved registers to be able to use functions without 
`\\__attribute__\((interrupt*))` annotation.

NOTE: those are usually wrapped with `extern "C"` anyway

It also requires preinitialized table with pointer to startup code, `sp`, and `gp`, and of course
any other addition like Zcmt `JVT` csr.

This table is also not necessarily smaller than software setup, e.g. `sp` can be usually
done with single `lui` instruction. At the cost of a bit added HW complexity.

There is still a risk of corruption if the compiler decides to reorder something before
initialization of `.data`/`.bss` sections.

Of course I often find that there is a competition on who will make
the worst startup code in assembly. 
So pure C/C++ startup code turns out to be "better" due to confirmation effect.
But let's have a look at my "combotablecrt" implementation <<combotablecrt>> for stm32f030x4/6. 
Is your compiler able to do that?

There is also a case of interrupt handlers that are using only a few registers
and don't need to take latency of the whole ABI.

==== ABIs with less caller saved registers

The rationale of introducing ABIs with reduced number of caller saved registers is to 
reduce interrupt latency. 

The major downside of such approach is lowered overall performance 
and code denisty. Which is highly unliked across riscv community <<bhvseabi>> and stalls 
development of such (E)ABI.

> I think for marketing reasons we should have the RISC-V EABI mimic the competitor ABI as 
> closely as possible, and be available and supported by the tools, even if almost no-one 
> should end up actually using it.

An alternative is to provide interrupts with defacto customized ABIs by e.g. <<prestacked annotation>>
and handle the function call pressure by <<IPRA>>.

==== "you are better of with soft stacking in inline handlers"

aka generic riscv `\\__attribute__\((interrupt))`

First issue is decreased code density due to all of the stacking code.

Compilers also barely care about optimizing for register pressure in interrupts.
The prologues/epilogues seem to be completely transparent for code generation.
It is especially visible in cases where majority of the prologue/epilogue code could be easily conditionally skipped.
(just the loads/stores, stack can be fully preserved on entry)

NOTE: avr8-gcc for a very long time was emitting useless prologues/epilogues for pushing `SREG`, `r0`, `r1` and clearing `r1`
even though those were not affected or used by ISR code. Of course the version that finally fixed it, was never 
shipped in Atmel Studio.

NOTE: Zcmp[e] doesn't cover caller saved registers except `ra`.



the other

principle of
how entering interrupts works

an entry is fetched from vector table
Then the core starts fetching

waitstates



even by the special push instructions for CSRs, `a` and `t` registers


==== EABI for RVE must being subset of RVI EABI

to be able to call RVE only code from RVI ABI

common in eabi proposals
static compiled


the idea is to provide precompiled libraries
code arbitrarily compiled for RVE might turn out to be less efficient than

==== one universal for everyones use cases

high flexibility
causes redundancy
waste of

==== handler return pattern

NVIC and emb-riscv

==== vector tables containing jump instructions

supposedly

works in classic ARM FIQ, and 8051 assembly

==== memory mapped vs CSR mapped configuration

in case of mass initialization

==== trampoline 

introduced by CLIC


=== required ABI

ideally not change
avoid disruption

definitely get rid of `tp` register

==== RV32E

==== RV32I

=== stack alignment



=== tooling issues to solve

==== prestacked annotation

//e.g. `tp` cannot be changed to caller saved due to existing hardware pre-stackers (ch32)

==== IPRA

in llvm <<llvmipra>>

in simple explanation



very little information foundable can be googled
mostly llvm 

even if there is something benchmarked
of course -O3 (forget about -Os and -Oz)



//???===== regression due to

==== automatic selection of regpush on isr entry config

== programmers model
//?????
//non profile ext

//common
	//optional tiny vect table

//profiles
//tiny
	//limited features
	//??

//medium

[appendix]
== appendix


[bibliography]
== Bibliography

* [[[embriscv, 1]]] https://github.com/emb-riscv/specs-markdown
* [[[clic, 2]]] https://github.com/riscv/riscv-fast-interrupt/blob/master/clic.adoc
* [[[clint, 3]]] https://github.com/riscv/riscv-aclint/blob/main/riscv-aclint.adoc
* [[[sififeintcookbook, 4]]] https://starfivetech.com/uploads/sifive-interrupt-cookbook-v1p2.pdf
* [[[plic, 5]]] https://github.com/riscv/riscv-plic-spec
* [[[aia, 6]]] https://github.com/riscv/riscv-aia
* [[[combotablecrt, 7]]] https://github.com/jnk0le/simple-crt/blob/master/cm0/combotablecrt_stm32f030x6.S
* [[[llvmipra, 8]]] https://reviews.llvm.org/D23980
* [[[picorvint, 9]]] https://github.com/YosysHQ/picorv32#custom-instructions-for-irq-handling
* [[[bhvseabi, 10]]] https://groups.google.com/a/groups.riscv.org/g/sw-dev/c/znKeVnmxsy8/m/NtdDII3kAAAJ